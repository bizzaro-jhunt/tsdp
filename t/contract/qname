#!/usr/bin/perl
use strict;
use warnings;

my $rc = 0;
sub ok($) {
	print "ok ", $_[0], "\n";
}
sub notok($) {
	print "not ok ", $_[0], "\n";
	$rc = 1;
}

# some singleton base cases
chomp(my $out = qx(./t/contract/r/qname-base 2>&1));
my $exit = $? >> 8;
if ($exit == 0) {
	ok "base qname tests hold";
} else {
	notok "base qname tests failed";
	print "$out\n";
	exit 1;
}

while (<DATA>) {
	chomp;
	s/\s*#\s*(.*)//;
	my $comment = $1 ? "$1 - " : "";
	my ($test) = m/([a-z]+)\s/ or next;
	$comment = "[$test] $comment";

	if ($test eq 'string') {
		my ($in, $want) = m/$test\s+(.*?)\s+>>\s+(.*)/;
		$in =~ s|\\|\\\\|g; # avoid premature unescapes.
		chomp(my $out = qx(echo '$in' | ./t/contract/r/qname-string 2>&1));
		if ($out ne $want) {
			notok "${comment}[$in] did not yield [$want] (was [$out])";
		} else {
			chomp(my $out = qx(echo '$in' | ./t/contract/r/qname-dup 2>&1));
			if ($out ne $want) {
				notok "${comment}[$in] did not (DUP) yield [$want] (was [$out])";
			} else {
				ok "${comment}[$in] yields [$want]";
			}
		}

	} elsif ($test =~ m/^(equiv|match)$/) {
		my ($a, $rel, $b) = m/$test\s+(.*?)\s+([~!])\s+(.*)/;
		chomp(my $err = qx(./t/contract/r/qname-${test} '$a' '$rel' '$b' </dev/null 2>&1));
		my $exit = $? >> 8;
		if ($exit == 0) {
			ok "${comment}$a $rel $b holds";
		} elsif ($exit == 1) {
			notok "${comment}$a $rel $b does not hold";
		} else {
			notok "${comment}$a $rel $b does not hold (rc=$exit; err=$err)";
		}

	} elsif ($test eq 'max') {
		my ($len, $ok) = m/$test\s+(\d+)\s+(ok|fail)/;
		for my $slug (qw(a$_=$_ k$_ w$_=*)) {
			my $s = join(',', map { eval "\"$slug\"" } 1..$len);
			chomp(my $err = qx(./t/contract/r/qname-${test} '$s' </dev/null 2>&1));
			my $exit = $? >> 8;
			if ($exit == 0) {
				if ($ok eq 'ok') {
					notok "${comment}$len ($slug) pairs was too long (and should be fine)"
				} else {
					ok "${comment}$len ($slug) pairs is too long (as it should be)"
				}
			} else {
				if ($ok eq 'ok') {
					ok "${comment}$len ($slug) pairs is not too long (that's correct)"
				} else {
					notok "${comment}$len ($slug) pairs is not too long (rc=$exit; err=$err)";
				}
			}
		}

	} else {
		notok "invalid test: ${test}"
	}
}
exit $rc;

__DATA__
string a=b       >> a=b        # base case
string abc=d     >> abc=d      # multi-character key
string a=def     >> a=def      # multi-character value
string abc=def   >> abc=def    # multi-character key and value
string a=b,c=d   >> a=b,c=d    # compound case (pre-ordered)
string c=d,a=b   >> a=b,c=d    # compound case re-ordered
string *         >> *          # single wildcard
string a=*       >> a=*        # partial match
string a=*,c=d   >> a=*,c=d    # interior partial match
string a=b,*     >> a=b,*      # trailing wildcard
string a = b     >> a=b        # key/value delimiter whitespace
string a   =  b  >> a=b        # repeated whitespace
string a=b , c=d >> a=b,c=d    # pair delimiter whitespace
string a=b c,d=e >> a=b c,d=e  # whitespace preservation
string a=\b      >> a=b        # non-escape pass-through (values)
string \a=\b     >> a=b        # non-escape pass-through (keys)
string a=b\ c    >> a=b c      # whitespace escaped
string yes=no    >> yes=no     # multi-char keys / values
string set       >> set        # omitted value eof
string a=,b      >> a,b        # omitted value=
string a,b       >> a,b        # omitted value,

equiv <nil>   ! <nil>          # nil/nil inequality
equiv <nil>   ! a=b            # nil/!nil inequality
equiv a=b     ! <nil>          # !nil/nil inequality
equiv a=b     ~ a=b            # base case
equiv a=b,c=d ~ a=b,c=d        # multiple keys
equiv a=b     ! a=c            # negative base case (values)
equiv a=b     ! c=b            # negative base case (keys)
equiv a=b     ! a=             # missing value
equiv a=b,c=d ! a=b            # arity mismatch
equiv a=b,*   ! a=b            # wildcard mismatch
equiv a=b,*   ~ a=b,*          # wildcard equality

match <nil>   ! <nil>          # nil/nil mismatch
match <nil>   ! a=b            # nil/!nil mismatch
match a=b     ! <nil>          # !nil/nil mismatch
match a=b     ~ a=b            # literal match
match a=b     ~ a=*            # partial match
match a=b,c=d ~ a=*,c=d        # interior partial match
match a=b,c=d ~ a=b,*          # wildcard match
match a=b,c=d ~ a=*,*          # wildcard + partial match
match a=b,c=d ! a=*            # partial match scope
match a=b     ! a=c            # value mismatch
match a=b     ! a=             # missing value
match a=b     ! c=d            # key mismatch
match a=b     ! c=d,*          # pattern constraint
match a=b     ~ a=b,*          # superfluous wildcard
match a=b,c=d ! a=b            # arity mismatch

max 1 ok
max 64 ok
max 65 fail
max 66 fail
max 128 fail
